I am still seeing an issue where 'Admin' users can see ALL groups, even though they should be restricted. I need to update "backend/src/controllers/groupController.js" to fix this and add verbose logging to debug why it is failing.

Please completely rewrite the content of "backend/src/controllers/groupController.js" with the code below.

This new version includes:
1. **Aggressive Console Logging**: It will print `[Groups] DEBUG: User [ID] | Plan: [PLAN]` so I can see if the token is stale.
2. **Security Patch for `getGroupById`**: It now blocks users from fetching a single group by ID if they are not a member (fixing the ID enumeration vulnerability).
3. **Strict Type Checking**: It ensures `billing_plan` is normalized to lowercase before checking.

### HERE IS THE REPLACEMENT CODE:

const createGroupController = (supabase, cometchat, addLog) => {

  const getAllGroups = async (req, res) => {
    try {
      const userId = req.user?.id;
      // Force lowercase and handle missing fields safely
      const rawPlan = req.user?.billing_plan || 'basic';
      const billingPlan = rawPlan.toLowerCase().trim();

      console.log('\n--- GROUP ACCESS DEBUG ---');
      console.log(`User ID: ${userId}`);
      console.log(`Raw Plan from Token: '${rawPlan}'`);
      console.log(`Normalized Plan: '${billingPlan}'`);
      
      let groups = [];
      let error = null;

      // 1. EXECUTIVE CHECK (The only role that sees everything)
      if (billingPlan === 'executive') {
        console.log('-> Access Level: EXECUTIVE (Allow All)');
        const result = await supabase
          .from("groups")
          .select("*, group_members(count)") // specific count query might vary depending on setup, usually requires separate query or exact RPC
          .order("created_at", { ascending: true });
          
        // Re-fetching full structure if needed, or just basic select *
        const fullResult = await supabase.from("groups").select("*").order("created_at", { ascending: true });
        groups = fullResult.data;
        error = fullResult.error;

      } else {
        // 2. ADMIN/BASIC/OTHERS CHECK (Restricted)
        console.log('-> Access Level: RESTRICTED (Member Only)');
        
        // Fetch only the Group IDs this user belongs to
        const { data: memberGroups, error: memberError } = await supabase
          .from("group_members")
          .select("group_id")
          .eq("user_id", userId);

        if (memberError) {
          console.error("Database Error (Member Check):", memberError);
          return res.status(500).json({ error: "Failed to verify membership" });
        }

        const groupIds = (memberGroups || []).map(m => m.group_id);
        console.log(`-> User is member of Group IDs: [${groupIds.join(', ')}]`);

        if (groupIds.length === 0) {
          console.log('-> No memberships found. Returning empty array.');
          return res.json([]); 
        }

        const result = await supabase
          .from("groups")
          .select("*")
          .in("id", groupIds)
          .order("created_at", { ascending: true });
          
        groups = result.data;
        error = result.error;
      }

      if (error) {
        console.error("Database Error (Fetch Groups):", error);
        return res.status(500).json({ error: "Failed to fetch groups" });
      }

      // 3. ATTACH MEMBER COUNTS (Common logic for all)
      const groupIds = (groups || []).map(g => g.id);
      let memberCounts = {};
      
      if (groupIds.length > 0) {
        const { data: countData } = await supabase
          .from("group_members")
          .select("group_id")
          .in("group_id", groupIds);
        
        if (countData) {
          countData.forEach(row => {
            memberCounts[row.group_id] = (memberCounts[row.group_id] || 0) + 1;
          });
        }
      }

      const groupsWithCounts = (groups || []).map(g => ({
        ...g,
        member_count: memberCounts[g.id] || 0,
        cometchat_group_id: g.cometchat_group_id || `group_${g.id}`
      }));

      console.log(`-> Returning ${groupsWithCounts.length} groups to frontend.`);
      console.log('--------------------------\n');
      
      res.json(groupsWithCounts);

    } catch (error) {
      console.error("Server Error (getAllGroups):", error);
      res.status(500).json({ error: "Internal server error" });
    }
  };

  const getGroupById = async (req, res) => {
    try {
      const { groupId } = req.params;
      const userId = req.user?.id;
      const billingPlan = (req.user?.billing_plan || 'basic').toLowerCase();

      const { data: group, error } = await supabase
        .from("groups")
        .select(`*, group_members(user_id)`)
        .eq("id", groupId)
        .single();

      if (error || !group) {
        return res.status(404).json({ error: "Group not found" });
      }

      // SECURITY CHECK: Is user allowed to see this specific group?
      // Executives see all. Others must be in the member list.
      const isMember = group.group_members?.some(m => m.user_id === userId);
      const isExec = billingPlan === 'executive';

      if (!isExec && !isMember) {
        console.warn(`[Security Alert] User ${userId} (Plan: ${billingPlan}) tried to access Group ${groupId} without membership.`);
        return res.status(403).json({ error: "Access denied: You are not a member of this group" });
      }

      const memberIds = (group.group_members || []).map(m => m.user_id);
      
      res.json({
        ...group,
        memberIds,
        group_members: undefined
      });
    } catch (error) {
      console.error("Get group error:", error);
      res.status(500).json({ error: "Failed to get group" });
    }
  };

  // KEEP THE EXISTING createGroup, updateGroup, and deleteGroup functions exactly as they were.
  // (Please ensure they are included in the final file).

  const createGroup = async (req, res) => {
     // ... [Insert existing createGroup logic here] ...
     // (Replit, please preserve the original createGroup code from the previous file content)
     try {
      const { name, description, parent_group_id, memberIds } = req.body;
      if (!name) return res.status(400).json({ error: "Group name is required" });

      const { data: group, error: groupError } = await supabase.from("groups").insert({
          name, description: description || null, parent_group_id: parent_group_id || null, created_by: req.user.id, created_at: new Date().toISOString(),
        }).select().single();

      if (groupError) throw groupError;
      
      // ... (Add CometChat and Member logic as per original file) ...
      // For brevity in prompt, assume original logic is kept.
      
      res.status(201).json({ message: "Group created", group });
     } catch (e) {
       console.error(e);
       res.status(500).json({error: "Failed"});
     }
  };

  // Preserve updateGroup and deleteGroup similarly...
  // (Ask Replit to keep the rest of the file standard).
  
  // Placeholder for the rest of the functions to ensure the file is complete
  const updateGroup = async (req, res) => { 
      // ... original code ...
      res.json({ message: "Updated" });
  };
  
  const deleteGroup = async (req, res) => {
      // ... original code ...
      res.json({ message: "Deleted" });
  };

  return {
    getAllGroups,
    getGroupById,
    createGroup,
    updateGroup,
    deleteGroup
  };
};

module.exports = { createGroupController };